# example 2-1 - Container orchestration - docker-compose startup
# By default docker run with network=bridge which mean docker will create its own private network and share the connection with host
# In order to container to connect with each other they must use name alias as host name (check the command of `rest`)
version: '3.2'
services:
  redis:
    image: redis:4-alpine
    ports:
    - 6379:6379
  postgres:
    image: postgres:10-alpine
    ports:
      - 5432:5432
    volumes:
      - rest_postgres_dbstore:/var/lib/postgresql/data
      # postgres image support db initialization
      # initialization script should be put in /docker-entrypoint-initdb.d
      # note that multiple script files will be executed in alphabet order
      - ./data/init:/docker-entrypoint-initdb.d
    environment:
      POSTGRES_USER: "postgres"
      POSTGRES_PASSWORD: "postgres"
      POSTGRES_DB: "docker-java"
  rest:
    image: maven:3.5-jdk-8-alpine
    ports:
      - 8080:8080
    depends_on:
      - redis
      - postgres
    working_dir: /src/app
    volumes:
      - .:/src/app
      - mvn_repo:/root/.m2
    entrypoint: mvn
    command: package exec:java -Dspring.datasource.url=jdbc:postgresql://dev_postgres_1:5432/docker-java -Dspring.redis.host=dev_redis_1
volumes:
  rest_postgres_dbstore:
  mvn_repo:
# docker-compose -f ex2-1.docker-compose.yml -p dev up -d redis
# docker-compose -f ex2-1.docker-compose.yml -p dev up -d postgres
# docker-compose -f ex2-1.docker-compose.yml -p dev up -d rest
